from dataclasses import dataclass
import json
import re
import sys
from typing import List


if len(sys.argv) < 2:
    sys.stderr.write("No input filename specified.\n")
    sys.exit(1)

input_filename = sys.argv[1]


@dataclass(frozen=True)
class RuleStatement(object):
    source: str
    flags: List[str]
    target: str

    def json(self):
        return {
            "source": self.source,
            "flags": self.flags,
            "target": self.target,
        }


@dataclass(frozen=True)
class CommentStatement(object):
    text: str

    def json(self):
        return {
            "text": self.text,
        }


rulesets = {}

ruleset_start = re.compile(r"^export const ([A-Z_]+):? ")
ruleset_finish = re.compile(r"^];$")
comment = re.compile(r"^\s*//(.*)")
rule = re.compile(r"^\s*\{ source: /(.*)/([a-z]*), target: '(.*)' \},$")
rule_multiline_start = re.compile(r"^\s*\{$")
rule_multiline_finish = re.compile(r"^\s*\},$")
rule_multiline_source = re.compile(r"^\s*source: /(.*)/([a-z]*),$")
rule_multiline_target = re.compile(r"^\s*target: '(.*)',$")

with open(input_filename, "r") as rulef:
    statements = []
    ruleset_name = None
    line_counter = 0

    inside_multiline_rule = False
    multiline_source = None
    multiline_flags = None
    multiline_target = None

    for line in rulef:
        line_counter += 1

        ruleset_start_match = ruleset_start.match(line)
        if ruleset_start_match:
            if ruleset_name:
                raise Exception(f"Line {line_counter}: Found a new ruleset before the previous one was finished.")
            elif inside_multiline_rule:
                raise Exception(f"Line {line_counter}: Found a new ruleset while processing a multiline rule.")
            else:
                ruleset_name = ruleset_start_match.group(1)
                #print(f"starting new ruleset {ruleset_name}")
                continue

        ruleset_finish_match = ruleset_finish.match(line)
        if ruleset_finish_match:
            if inside_multiline_rule:
                raise Exception(f"Line {line_counter}: Found end of ruleset while processing a multiline rule.")
            elif ruleset_name:
                #print(f"finishing ruleset {ruleset_name}")
                rulesets[ruleset_name] = statements
                statements = []
                ruleset_name = None
                continue
            else:
                raise Exception(f"Line {line_counter}: Found end of ruleset but was not processing a ruleset.")

        if not ruleset_name:
            continue

        if inside_multiline_rule:
            rule_multiline_finish_match = rule_multiline_finish.match(line)
            if rule_multiline_finish_match:
                if not multiline_source or not multiline_flags or not multiline_target:
                    raise Exception(f"Line {line_counter}: Processed incomplete multiline rule.")
                statements.append(RuleStatement(source=multiline_source, flags=multiline_flags, target=multiline_target))
                inside_multiline_rule = False
                multiline_source = multiline_flags = multiline_target = None
                continue

            rule_multiline_source_match = rule_multiline_source.match(line)
            if rule_multiline_source_match:
                multiline_source = rule_multiline_source_match.group(1)
                multiline_flags = list(rule_multiline_source_match.group(2))
                continue

            rule_multiline_target_match = rule_multiline_target.match(line)
            if rule_multiline_target_match:
                multiline_target = rule_multiline_target_match.group(1)
                continue

            continue

        rule_multiline_start_match = rule_multiline_start.match(line)
        if rule_multiline_start_match:
            if inside_multiline_rule:
                raise Exception(f"Line {line_counter}: Found a new multiline rule before the previous one was finished.")
            else:
                inside_multiline_rule = True
                continue

        comment_match = comment.match(line)
        if comment_match:
            statements.append(CommentStatement(text=comment_match.group(1)))
            continue

        rule_match = rule.match(line)
        if rule_match:
            statements.append(RuleStatement(source=rule_match.group(1), flags=list(rule_match.group(2)), target=rule_match.group(3)))
            continue


#final = json.dumps(rulesets, default=lambda o: o.json(), indent=4)
#print(final)

print('"""\nDO NOT MODIFY THIS FILE DIRECTLY!\nIt is automatically generated by regen.sh\n"""\n\n')
print("from dataclasses import dataclass\nimport re\n\n")
print("@dataclass(frozen=True)\nclass FilterRule(object):\n    source: re.Pattern\n    target: str = \"\"\n    count: int = 0\n")
for ruleset_name, statements in rulesets.items():
    print("")
    print(f"{ruleset_name} = (")

    for statement in statements:
        if isinstance(statement, CommentStatement):
            print(f"    #{statement.text}")
        elif isinstance(statement, RuleStatement):
            flag_objs = []
            count = 1
            for flag in statement.flags:
                if flag == "i":
                    flag_objs.append("re.IGNORECASE")
                elif flag == "g":
                    count = 0

            source_arg = 're.compile(r"""' + statement.source + '"""'
            if len(flag_objs) > 0:
                source_arg += ', flags=' + " | ".join(flag_objs) + ')'
            else:
                source_arg += ')'

            args = ['source=' + source_arg]
            if statement.target:
                args.append('target=r"""' + statement.target.replace("$", "\\") + '"""')
            if count > 0:
                args.append('count=' + str(count))

            print('    FilterRule(\n        ' + ",\n        ".join(args) + ',\n    ),')

    print(")")

print("\n")
print("__all__ = (")
print('    "FilterRule",')
for ruleset_name in rulesets.keys():
    print(f'    "{ruleset_name}",')
print(")")
